/*
The relevant part of the database
since this is gonna be for the milestone APIs

CREATE TABLE "common_mistakes" (
  "id" INTEGER GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
  "topic_id" INTEGER NOT NULL,
  "title" VARCHAR(100) NOT NULL,
  "description" TEXT NULL,
  "content" TEXT,
  "video_url" VARCHAR(200),
  "created_at" TIMESTAMP DEFAULT NOW(),
  FOREIGN KEY ("topic_id") REFERENCES "topics" ("id") ON DELETE CASCADE
);

CREATE TABLE "user_common_mistake_completions" (
  "id" INTEGER GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
  "user_id" INTEGER NOT NULL,
  "common_mistake_id" INTEGER NOT NULL,
  FOREIGN KEY ("user_id") REFERENCES "users" ("id") ON DELETE CASCADE,
  FOREIGN KEY ("common_mistake_id") REFERENCES "common_mistakes" ("id") ON DELETE CASCADE,
  UNIQUE ("user_id", "common_mistake_id")  -- Ensure a user can't review the same mistake twice
);

CREATE TYPE related_type AS ENUM ('milestone', 'common_mistake');

-- Table to store quizzes associated with either milestones or common mistakes
CREATE TABLE "quizzes" (
  "id" INTEGER GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
  "title" VARCHAR(100) NOT NULL,
  "description" TEXT,
  "related_id" INTEGER NOT NULL,
  "related_type" related_type NOT NULL,
  "created_at" TIMESTAMP DEFAULT NOW()
);

-- the 35 questions
CREATE TABLE "quiz_questions" (
  "id" INTEGER GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
  "quiz_id" INTEGER NOT NULL,
  "question_text" TEXT NOT NULL,
  "created_at" TIMESTAMP DEFAULT NOW(),
  FOREIGN KEY ("quiz_id") REFERENCES "quizzes" ("id") ON DELETE CASCADE
);

-- This will be the 4 choces
CREATE TABLE "quiz_options" (
  "id" INTEGER GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
  "question_id" INTEGER NOT NULL,
  "option_text" TEXT NOT NULL,
  "is_correct" BOOLEAN NOT NULL,
  "created_at" TIMESTAMP DEFAULT NOW(),
  FOREIGN KEY ("question_id") REFERENCES "quiz_questions" ("id") ON DELETE CASCADE
);


CREATE TABLE "user_topic_completions" (
  "id" INTEGER GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
  "user_id" INTEGER NOT NULL,
  "course_id" INTEGER NOT NULL,
  "topic_id" INTEGER NOT NULL,
  "completed" BOOLEAN DEFAULT FALSE,
    "progress_markers" INTEGER DEFAULT 0, -- Both common mistakes and milestones are treated as progress markers
  "created_at" TIMESTAMP DEFAULT NOW(),
  FOREIGN KEY ("user_id") REFERENCES "users" ("id") ON DELETE CASCADE,
  FOREIGN KEY ("course_id") REFERENCES "courses" ("id") ON DELETE CASCADE,
  FOREIGN KEY ("topic_id") REFERENCES "topics" ("id") ON DELETE CASCADE
);

CREATE TABLE "topics" (
  "id" INTEGER GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
  "course_id" INTEGER NOT NULL,
  "name" VARCHAR(100) NOT NULL,
  "description" TEXT,
  "order" INTEGER NOT NULL,
  "total_markers" INTEGER NOT NULL,
  "created_at" TIMESTAMP DEFAULT NOW(),
  FOREIGN KEY ("course_id") REFERENCES "courses" ("id") ON DELETE CASCADE
);

*/

/*
The relevant part of the database
since this is gonna be for the common mistakes APIs

CREATE TABLE "common_mistakes" (
  "id" INTEGER GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
  "topic_id" INTEGER NOT NULL,
  "title" VARCHAR(100) NOT NULL,
  "description" TEXT NULL,
  "content" TEXT,
  "video_url" VARCHAR(200),
  "created_at" TIMESTAMP DEFAULT NOW(),
  FOREIGN KEY ("topic_id") REFERENCES "topics" ("id") ON DELETE CASCADE
);

CREATE TABLE "user_common_mistake_completions" (
  "id" INTEGER GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
  "user_id" INTEGER NOT NULL,
  "mistake_id" INTEGER NOT NULL,
  "completed" BOOLEAN DEFAULT FALSE,
  "completed_at" TIMESTAMP DEFAULT NOW(),
  FOREIGN KEY ("user_id") REFERENCES "users" ("id") ON DELETE CASCADE,
  FOREIGN KEY ("mistake_id") REFERENCES "common_mistakes" ("id") ON DELETE CASCADE,
  UNIQUE ("user_id", "mistake_id") -- Ensure a user can't complete the same mistake twice
);

-- The quizzes and questions table remains the same with related_type 'common_mistake'
*/

const pool = require("../config/db");

const {
  get_random_questions_for_quiz,
  fetch_quiz_questions,
  fetch_quizzes_with_details,
} = require("../helper_repository/quizzes_repository");

const get_common_mistake_by_id = async (mistake_id) => {
    try {
        const result = await pool.query(`
          SELECT
            cm.id AS mistake_id,
            cm.title AS mistake_title,
            cm.description AS mistake_description,
            cm.content AS mistake_content,
            cm.video_url AS mistake_video_url,
            q.id AS quiz_id,
            q.title AS quiz_title,
            q.description AS quiz_description
        FROM
            common_mistakes cm
        LEFT JOIN quizzes q ON cm.id = q.related_id AND q.related_type = 'common_mistake'
        WHERE
            cm.id = $1
        `, [mistake_id]);

        if (result.rows.length === 0) {
            return null;
        }

        return result.rows[0];
    } catch (err) {
        throw err;
    }
};

const mark_mistake_as_completed = async (mistake_id, user_id, check_for_quiz = true) => {
    try {
        const existingCompletion = await pool.query(`
            SELECT completed FROM user_common_mistake_completions
            WHERE user_id = $1 AND common_mistake_id = $2
        `, [user_id, mistake_id]);

        if (existingCompletion.rows.length > 0 && existingCompletion.rows[0].completed) {
            return { success: true, message: "Mistake already completed." };
        }

        if (check_for_quiz) {
            const quizCheck = await pool.query(`
                SELECT q.id AS quiz_id
                FROM quizzes q
                WHERE q.related_id = $1 AND q.related_type = 'common_mistake'
            `, [mistake_id]);

            if (quizCheck.rows.length > 0) {
                throw new Error("Cannot mark mistake as completed before quiz is solved.");
            }
        }

        const result = await pool.query(`
            INSERT INTO user_common_mistake_completions (user_id, common_mistake_id, completed)
            VALUES ($1, $2, TRUE)
            ON CONFLICT (user_id, common_mistake_id) DO UPDATE
            SET completed = TRUE, completed_at = NOW()
            RETURNING common_mistake_id
        `, [user_id, mistake_id]);

        if (result.rows.length === 0) {
            throw new Error("Failed to mark mistake as completed.");
        }

        const { topic_completed, topic_id } = await update_user_topic_progress_for_mistake(mistake_id, user_id);
        return { mistake_completed: true, topic_completed: topic_completed, topic_id: topic_completed ? topic_id : null };
    } catch (err) {
        throw err;
    }
};

const update_user_topic_progress_for_mistake = async (mistake_id, user_id) => {
    try {
        const topicResult = await pool.query(`
            SELECT t.id AS topic_id, t.total_markers
            FROM topics t
            JOIN common_mistakes cm ON t.id = cm.topic_id
            WHERE cm.id = $1
        `, [mistake_id]);

        const topic = topicResult.rows[0];

        if (!topic) {
            throw new Error("Topic not found for mistake.");
        }

        const existingTopicCompletion = await pool.query(`
            SELECT completed FROM user_topic_completions
            WHERE user_id = $1 AND topic_id = $2
        `, [user_id, topic.topic_id]);

        if (existingTopicCompletion.rows.length > 0 && existingTopicCompletion.rows[0].completed) {
            return { topicCompleted: true, message: "Topic already completed." };
        }

        const updateResult = await pool.query(`
            UPDATE user_topic_completions
            SET progress_markers = progress_markers + 1
            WHERE user_id = $1 AND topic_id = $2
            RETURNING progress_markers
        `, [user_id, topic.topic_id]);

        const progressMarkers = updateResult.rows[0].progress_markers;
        const completionPercentage = (progressMarkers / topic.total_markers) * 100;
        if (completionPercentage >= 70) {
            await pool.query(`
                UPDATE user_topic_completions
                SET completed = TRUE
                WHERE user_id = $1 AND topic_id = $2
            `, [user_id, topic.topic_id]);
            return { topic_completed: true, topic_id: topic.topic_id };
        }
        return { topic_completed: false };
    } catch (err) {
        throw err;
    }
};

const get_random_quiz_for_unsolved_mistake = async (mistake_id, user_id) => {
    try {
        const quiz_result = await pool.query(`
            SELECT id AS quiz_id
            FROM quizzes 
            WHERE related_id = $1 AND related_type = 'common_mistake'
        `, [mistake_id]);

        if (quiz_result.rows.length === 0) {
            throw new Error("No quiz found for this mistake.");
        }

        const quiz_id = quiz_result.rows[0].quiz_id;

        const completion_check = await pool.query(`
            SELECT 1 
            FROM user_common_mistake_completions 
            WHERE user_id = $1 AND common_mistake_id = $2
        `, [user_id, mistake_id]);

        if (completion_check.rows.length > 0) {
            throw new Error("Mistake already completed.");
        }

        const random_questions = await get_random_questions_for_quiz(quiz_id, 5);
        return { quiz_id, quiz: random_questions };
    } catch (err) {
        throw err;
    }
};

const get_all_quiz_for_solved_mistake = async (mistake_id, user_id) => {
    try {
        const quiz_result = await pool.query(`
            SELECT id AS quiz_id
            FROM quizzes 
            WHERE related_id = $1 AND related_type = 'common_mistake'
        `, [mistake_id]);

        if (quiz_result.rows.length === 0) {
            throw new Error("No quiz found for this mistake.");
        }

        const quiz_id = quiz_result.rows[0].quiz_id;

        const completion_check = await pool.query(`
            SELECT completed 
            FROM user_common_mistake_completions 
            WHERE user_id = $1 AND common_mistake_id = $2
        `, [user_id, mistake_id]);

        if (completion_check.rows.length === 0 || !completion_check.rows[0].completed) {
            throw new Error("Mistake not completed yet.");
        }

        const completed_quiz = await fetch_quiz_questions(quiz_id);
        return { quiz: completed_quiz };
    } catch (err) {
        throw err;
    }
};



// something is different with the submit quiz for the misatke
const submit_quiz_for_mistake = async (mistake_id, quiz_id, user_id, submittedAnswers) => {
  try {
      const existingCompletion = await pool.query(`
          SELECT completed FROM user_common_mistake_completions
          WHERE user_id = $1 AND common_mistake_id = $2
      `, [user_id, mistake_id]);

      if (existingCompletion.rows.length > 0 && existingCompletion.rows[0].completed) {
          throw new Error("Mistake already completed.");
      }
      
      const correctOptions = await pool.query(`
          SELECT 
              qq.id AS question_id, 
              qo.id AS option_id, 
              qo.is_correct
          FROM quiz_questions qq
          JOIN quiz_options qo ON qq.id = qo.question_id
          WHERE qq.quiz_id = $1
      `, [quiz_id]);

      const correctAnswersMap = {};
      correctOptions.rows.forEach(option => {
          if (!correctAnswersMap[option.question_id]) {
              correctAnswersMap[option.question_id] = [];
          }
          if (option.is_correct) {
              correctAnswersMap[option.question_id].push(option.option_id);
          }
      });

      let score = 0;
      for (const answer of submittedAnswers) {
          const { question_id, selected_option_id } = answer;
          if (correctAnswersMap[question_id]?.includes(selected_option_id)) {
              score += 1;
          }
      }

      const passed = score >= 3;

      if (passed) {
        const completion_status = await mark_mistake_as_completed(mistake_id, user_id, false);

        const quizWithAnswers = await fetch_quizzes_with_details(quiz_id);

        return {
            passed: true,
            score,
            quiz: quizWithAnswers,
            completion_status,
        }
      } else {
        return {
            passed: false,
            score,
            message: "You did not pass the quiz. Please try again."
        }
      }

  } catch (err) {
      throw err;
  }
};

module.exports = {
    get_common_mistake_by_id,
    mark_mistake_as_completed,
    get_random_quiz_for_unsolved_mistake,
    get_all_quiz_for_solved_mistake,
    submit_quiz_for_mistake,
}