/*
The relevant part of the database
since this is gonna be for the milestone APIs

CREATE TABLE "milestones" (
  "id" INTEGER GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
  "topic_id" INTEGER NOT NULL,
  "title" VARCHAR(100) NOT NULL,
  "description" TEXT,
  "video_url" VARCHAR(200),
  "img_url" VARCHAR(200),
  "created_at" TIMESTAMP DEFAULT NOW(),
  FOREIGN KEY ("topic_id") REFERENCES "topics" ("id") ON DELETE CASCADE
);

CREATE TABLE "user_milestone_completions" (
  "id" INTEGER GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
  "user_id" INTEGER NOT NULL,
  "milestone_id" INTEGER NOT NULL,
  "completed" BOOLEAN DEFAULT FALSE,
  "completed_at" TIMESTAMP DEFAULT NOW(),
  FOREIGN KEY ("user_id") REFERENCES "users" ("id") ON DELETE CASCADE,
  FOREIGN KEY ("milestone_id") REFERENCES "milestones" ("id") ON DELETE CASCADE,
  UNIQUE ("user_id", "milestone_id")  -- Ensure a user can't complete the same milestone twice
);

CREATE TYPE related_type AS ENUM ('milestone', 'common_mistake');

-- Table to store quizzes associated with either milestones or common mistakes
CREATE TABLE "quizzes" (
  "id" INTEGER GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
  "title" VARCHAR(100) NOT NULL,
  "description" TEXT,
  "related_id" INTEGER NOT NULL,
  "related_type" related_type NOT NULL,
  "created_at" TIMESTAMP DEFAULT NOW()
);

-- the 35 questions
CREATE TABLE "quiz_questions" (
  "id" INTEGER GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
  "quiz_id" INTEGER NOT NULL,
  "question_text" TEXT NOT NULL,
  "created_at" TIMESTAMP DEFAULT NOW(),
  FOREIGN KEY ("quiz_id") REFERENCES "quizzes" ("id") ON DELETE CASCADE
);

-- This will be the 4 choces
CREATE TABLE "quiz_options" (
  "id" INTEGER GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
  "question_id" INTEGER NOT NULL,
  "option_text" TEXT NOT NULL,
  "is_correct" BOOLEAN NOT NULL,
  "created_at" TIMESTAMP DEFAULT NOW(),
  FOREIGN KEY ("question_id") REFERENCES "quiz_questions" ("id") ON DELETE CASCADE
);


CREATE TABLE "user_topic_completions" (
  "id" INTEGER GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
  "user_id" INTEGER NOT NULL,
  "course_id" INTEGER NOT NULL,
  "topic_id" INTEGER NOT NULL,
  "completed" BOOLEAN DEFAULT FALSE,
    "progress_markers" INTEGER DEFAULT 0, -- Both common mistakes and milestones are treated as progress markers
  "created_at" TIMESTAMP DEFAULT NOW(),
  FOREIGN KEY ("user_id") REFERENCES "users" ("id") ON DELETE CASCADE,
  FOREIGN KEY ("course_id") REFERENCES "courses" ("id") ON DELETE CASCADE,
  FOREIGN KEY ("topic_id") REFERENCES "topics" ("id") ON DELETE CASCADE
);

CREATE TABLE "topics" (
  "id" INTEGER GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
  "course_id" INTEGER NOT NULL,
  "name" VARCHAR(100) NOT NULL,
  "description" TEXT,
  "order" INTEGER NOT NULL,
  "total_markers" INTEGER NOT NULL,
  "created_at" TIMESTAMP DEFAULT NOW(),
  FOREIGN KEY ("course_id") REFERENCES "courses" ("id") ON DELETE CASCADE
);

*/

const pool = require("../config/db");

const {

  fetch_quizzes_with_details,
  get_random_questions_for_quiz,
  fetch_quiz_questions,
} = require("../helper_repository/quizzes_repository");

const get_milestone_by_id = async (milestone_id) => {
    try {
        const result = await pool.query(`
          SELECT
            m.id AS milestone_id,
            m.title AS milestone_title,
            m.description AS milestone_description,
            m.video_url AS milestone_video_url,
            m.img_url AS milestone_img_url,
            q.id AS quiz_id,
            q.title AS quiz_title,
            q.description AS quiz_description
        FROM
            milestones m
        LEFT JOIN quizzes q ON m.id = q.related_id  AND q.related_type = 'milestone'
        WHERE
            m.id = $1
        `, [milestone_id]); 

        if (result.rows.length === 0) {
            return null;
        }

        return result.rows[0];
    } catch (err) {
        throw err;
    }
}


// okay now we need to create the quiz API
// and a submit API
// And if the milestone is completed we should return the quiz data answered 
// We also need to add the API to mark the milestone as completed
// We also need to make sure that the markdown data is working fine
// Then I should complete the cloudFront setup and have the website as https using cloudfront and the BLOB
// Also update the topic completion number for the milestone and the common_mistake
// It is weird that I still use the milesstone as a common name


// 1) API for milestone that does not need a quiz to mark it as completed
//    we will first make sure there's no quiz for it otherwise we will return an error
//    we will also increase the progress marker for the user
//    here we also have to update the user_topic_completed attribute if passed 70% of the milestones
//    we will use the passed_markers and the total_markers for that topic

const mark_milestone_as_completed = async (milestone_id, user_id, check_for_quiz = true) => {
    try {
        // Check if the milestone is already marked as completed
        const existingCompletion = await pool.query(`
            SELECT completed FROM user_milestone_completions
            WHERE user_id = $1 AND milestone_id = $2
        `, [user_id, milestone_id]);

        if (existingCompletion.rows.length > 0 && existingCompletion.rows[0].completed) {
            return { success: true, message: "Milestone already completed." };
        }

        // Step 1: Only check if the milestone has a quiz when 'check_for_quiz' is true
        if (check_for_quiz) {
            const quizCheck = await pool.query(`
                SELECT q.id AS quiz_id
                FROM quizzes q
                WHERE q.related_id = $1 AND q.related_type = 'milestone'
            `, [milestone_id]);

            if (quizCheck.rows.length > 0) {
                // Milestone has a quiz, so the user must complete the quiz first
                throw new Error("Cannot mark milestone as completed before quiz is solved.");
            }
        }

        // Step 2: Mark the milestone as completed
        const result = await pool.query(`
            INSERT INTO user_milestone_completions (user_id, milestone_id, completed)
            VALUES ($1, $2, TRUE)
            ON CONFLICT (user_id, milestone_id) DO UPDATE
            SET completed = TRUE, completed_at = NOW()
            RETURNING milestone_id
        `, [user_id, milestone_id]);

        if (result.rows.length === 0) {
            throw new Error("Failed to mark milestone as completed.");
        }

        // Step 3: Update user's progress in the topic and check 70% completion
        const { topic_completed, topic_id } = await update_user_topic_progress(milestone_id, user_id);
        return { milestone_completed: true, topic_completed: topic_completed, topic_id: topic_completed ? topic_id : null };
    } catch (err) {
        throw err;
    }
};



const update_user_topic_progress = async (milestone_id, user_id) => {
    try {
        // Get the topic of the milestone
        const topicResult = await pool.query(`
            SELECT t.id AS topic_id, t.total_markers
            FROM topics t
            JOIN milestones m ON t.id = m.topic_id
            WHERE m.id = $1
        `, [milestone_id]);

        const topic = topicResult.rows[0];

        if (!topic) {
            throw new Error("Topic not found for milestone.");
        }

        // Check if the topic is already completed
        const existingTopicCompletion = await pool.query(`
            SELECT completed FROM user_topic_completions
            WHERE user_id = $1 AND topic_id = $2
        `, [user_id, topic.topic_id]);

        if (existingTopicCompletion.rows.length > 0 && existingTopicCompletion.rows[0].completed) {
            return { topicCompleted: true, message: "Topic already completed." };
        }

        // Increment progress markers
        const updateResult = await pool.query(`
            UPDATE user_topic_completions
            SET progress_markers = progress_markers + 1
            WHERE user_id = $1 AND topic_id = $2
            RETURNING progress_markers
        `, [user_id, topic.topic_id]);

        const progressMarkers = updateResult.rows[0].progress_markers;

        // Check if user has passed 70% of the topic's milestones/common mistakes
        const completionPercentage = (progressMarkers / topic.total_markers) * 100;
        if (completionPercentage >= 70) {
            await pool.query(`
                UPDATE user_topic_completions
                SET completed = TRUE
                WHERE user_id = $1 AND topic_id = $2
            `, [user_id, topic.topic_id]);
            return { topic_completed: true, topic_id: topic.topic_id };
        }
        return { topic_completed: false };
    } catch (err) {
        throw err;
    }
};


// 2) API to return the quiz data which are 5 random questions
//    but before that we will check if it was solved before
//    if was solved before we will return all the questions and their correct answers
//    if not we will return 5 random questions

const get_random_quiz_for_unsolved_milestone = async (milestone_id, user_id) => {
    try {
        // Step 1: Check if there's a quiz for this milestone
        const quiz_result = await pool.query(`
            SELECT id AS quiz_id
            FROM quizzes 
            WHERE related_id = $1 AND related_type = 'milestone'
        `, [milestone_id]);

        if (quiz_result.rows.length === 0) {
            throw new Error("No quiz found for this milestone.");
        }

        const quiz_id = quiz_result.rows[0].quiz_id;

        // Step 2: Check if the milestone is unsolved (no entry in completions)
        const completion_check = await pool.query(`
            SELECT 1 
            FROM user_milestone_completions 
            WHERE user_id = $1 AND milestone_id = $2
        `, [user_id, milestone_id]);

        if (completion_check.rows.length > 0) {
            throw new Error("Milestone already completed.");
        }

        // Step 3: Fetch random set of 5 questions
        const random_questions = await get_random_questions_for_quiz(quiz_id, 5);
        return {quiz_id, quiz: random_questions };
    } catch (err) {
        throw err;
    }
};


const get_all_quiz_for_solved_milestone = async (milestone_id, user_id) => {
    try {
        // Step 1: Check if there's a quiz for this milestone
        const quiz_result = await pool.query(`
            SELECT id AS quiz_id
            FROM quizzes 
            WHERE related_id = $1 AND related_type = 'milestone'
        `, [milestone_id]);

        if (quiz_result.rows.length === 0) {
            throw new Error("No quiz found for this milestone.");
        }

        const quiz_id = quiz_result.rows[0].quiz_id;

        // Step 2: Check if the milestone is solved (exists in completions)
        const completion_check = await pool.query(`
            SELECT completed 
            FROM user_milestone_completions 
            WHERE user_id = $1 AND milestone_id = $2
        `, [user_id, milestone_id]);

        if (completion_check.rows.length === 0 || !completion_check.rows[0].completed) {
            throw new Error("Milestone not completed yet.");
        }

        // Step 3: Fetch all questions with answers
        const completed_quiz = await fetch_quiz_questions(quiz_id);
        return { quiz: completed_quiz };
    } catch (err) {
        throw err;
    }
};


// 3) API to submit the quiz
//    we will check if the answers are correct
//    if they are correct we will mark the milestone as completed
//    and increase the progress marker for the user
//    if they are not correct we will return the score
//    and if he tries to enter again we will generate another 5 random questions
//    but if he passed we will return all the questions and their correct answers

const submit_quiz = async (milestone_id, quiz_id, user_id, submittedAnswers) => {
  try {

      const existingCompletion = await pool.query(`
            SELECT completed FROM user_milestone_completions
            WHERE user_id = $1 AND milestone_id = $2
      `, [user_id, milestone_id]);

        if (existingCompletion.rows.length > 0 && existingCompletion.rows[0].completed) {
            throw new Error("Milestone already completed.");
        }
        
      // Fetch correct options for each question in the quiz
      const correctOptions = await pool.query(`
          SELECT 
              qq.id AS question_id, 
              qo.id AS option_id, 
              qo.is_correct
          FROM quiz_questions qq
          JOIN quiz_options qo ON qq.id = qo.question_id
          WHERE qq.quiz_id = $1
      `, [quiz_id]);

      const correctAnswersMap = {};
      correctOptions.rows.forEach(option => {
          if (!correctAnswersMap[option.question_id]) {
              correctAnswersMap[option.question_id] = [];
          }
          if (option.is_correct) {
              correctAnswersMap[option.question_id].push(option.option_id);
          }
      });

      // Calculate score: Check how many answers were correct
      let score = 0;
      for (const answer of submittedAnswers) {
          const { question_id, selected_option_id } = answer;
          if (correctAnswersMap[question_id]?.includes(selected_option_id)) {
              score++;
          }
      }

      // Check if user passed (score >= 3)
      const passed = score >= 3;

      if (passed) {
          // Mark milestone as completed
          const completion_status = await mark_milestone_as_completed(milestone_id, user_id, false);

          // Fetch all quiz questions with correct answers
          const quizWithAnswers = await fetch_quizzes_with_details(quiz_id);
          
          return {
              passed: true,
              score,
              completion_status,
              quiz:quizWithAnswers,  // Return the correct answers
          };
      } else {
          // Return only the score and that the user did not pass
          return {
              passed: false,
              score,
              message: "You did not pass the quiz. Please try again!",
          };
      }
  } catch (err) {
      throw err;
  }
};



module.exports = {
    get_milestone_by_id,
    mark_milestone_as_completed,
    get_random_quiz_for_unsolved_milestone,
    get_all_quiz_for_solved_milestone,
    submit_quiz,
}